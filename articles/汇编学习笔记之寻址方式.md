# 汇编学习笔记之寻址方式

绝大对数汇编指令中都存在着操作数，而所谓**寻址方式就是CPU寻找指令中操作数在内存中的存放地址的方式。**

接下来将基于X86对各种寻址方式进行介绍。

### 一、立即寻址

立即寻址其实并不需要寻址，**指令中将直接给出操作数的值**。

比如：MOV AX, 5678H 

操作数5678H就是立即寻址获得，操作数AX则是寄存器直接寻址，这我们后面再详谈😉

### 二、直接寻址

直接寻址意味着**指令中将直接给出操作数所在内存单元的地址**。

诸如：MOV AX, DS:[0]  或MOV AX,DS:[s]（s为标号）

其中操作数DS:[0]和DS:[s]就是由直接寻址获取的。

注：在debug模式中写入指令，我们可以用[x] (x为立即数或标号)来表示内存地址，但在汇编源程序中书写指令时，[x]将被视作操作数，也就是[x]与x在汇编源程序被编译后将没有区别，而要想在汇编源程序中的[x]在被编译后表示内存地址，我们必须在书写时写出段地址。

### 三、寄存器直接寻址

寄存器直接寻址意味着**指令中给出的操作数的值，这个值存放于某个寄存器中**。

比如：MOV CX,AX

我们在介绍前两种寻址方式的时候就看到了寄存器直接寻址的身影，这种寻址方式也是我们最常见且最常用的寻址方式。

### 四、寄存器间接寻址

寄存器间接寻址意味着**指令中给出操作数的地址，这个地址对应着某个寄存器的值。**

比如：MOV CX,[AX]

在如上指令中，操作数[AX]由寄存器间接寻址获得，AX寄存器中的值将不会作为操作数，而是作为操作数的地址去寻找操作数。而在寄存器直接寻址中，AX寄存器中的值将直接被视作操作数。

寄存器间接寻址和寄存器直接寻址的关系就好像直接寻址和立即寻址的关系，只不过多了寄存器这个载体。

在直接寻址和间接寻址中：前者在指令中给出的是地址，而后者直接给出的是值。而在寄存器间接寻址和寄存器直接寻址中：前者在指令中同样是给出地址，后者给出的也是值，不过给出的地址或值是用寄存器中存放的值进行表述的罢了。

寄存器间接寻址和直接寻址不同的是：不强求我们在汇编源程序中写出段地址，因为许多寄存器有默认的段地址，大多数寄存器的段地址即DS寄存器的值，而少数寄存器如BP的段地址的值是SS寄存器的值。

### 五、相对寻址

相对寻址在寄存器间接寻址的基础上更进了一步：**指令中给出的操作数的地址，这个地址由某个寄存器中存放的值与立即数或标号运算得到。**

诸如：MOV CX, [AX+1]或MOV CX, [AX+S]

操作数[AX+1]和[AX+S]由相对寻址获得。

这种寻址方式与寄存器间接寻址基本一致，不过是在计算操作数地址的时候不能直接将寄存器中的值取出作为地址，而是要与立即数或标号进行运算后才能得到地址。

### 六、基址变址寻址

在说明什么是基址变址寻址前我们首先要明白什么是基址寄存器，什么是变址寄存器。基址寄存器其实就是BX和BP寄存器，而变址寄存器在8086中主要是SI(Source Index)和DI(Destination Index)。在这种寻址方式中：**指令给出操作数的地址，而该地址由基址寄存器和变址寄存器中存放的值计算得到。**

比如：MOV AX, [BP+SI]

操作数[BP+SI]就是由基址变址寻址获得。它将基址寄存器BP中的值和变址寄存器SI中的值相加得到了操作数的地址，再由该地址去寻找操作数。

### 七、相对基址变址寻址

相对基址变址寻址则是在基址变址寻址的基础上更进了一步：**指令给出操作数的地址，该地址由指令中给出的基址寄存器和变址寄存器以及立即数的值相运算得到。**

诸如：MOV [BP+SI+S]或MOV [BP+SI+1]

操作数[BP+SI+S]和[BP+SI+1]就是相对基址变址寻址的体现，它们不过是基址变址寻址的基础上多了一个立即数罢了，就好比相对寻址在寄存器间接寻址的基础上多了一个立即数。